1. look for worst case complexity , you can also optimize the best case as well(research ??)
2. we don't care about what the actual time taken is, we only care about the relationship , how the line is growing
3. by keeping 4 points in mind we can derive the complexity of any equation
4. constant is the best one
5. expression is a value , func and class are both expression and statement
6. big-oh -> our algo will not exceed the complexity of this
7. tight bound
8. big theta -> g(n) is both upper and lower bound on growth rate of f(n) for large values of n.
9. constant space complexity ???? -> done -> space complexity vs auxiliary space -> no new arrays created
10. in recursion -> functions that are linked with each other will be in the stack at the same time, and IT SHOULD BE IN ONE FLOW , SO YOU CANNOT INTERLINK UP AND DOWN direction fucn calls because they are not in one direction
11. height of recursion tree -> space complexity(auxiliary space)
12. so in recursion tree at one level , there will not be more than one func calls in stack at same time
13. max amt of space required at a time , so space complexity of recursive programs = height(total no. of calls / nodes in path) of tree
14. recurrence relations -> represent recursion in form of equation
15. solve any recurrence relation of divide and conquer -> akra-baazi
16. linear recurrence relations -> 

*******************************************************************************************************************

-> if your code is that much optimized , it will handle small data 